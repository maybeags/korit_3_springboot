# 입실 체크 해주세요 !! 🏎

# SpringBoot RESTful API
## REST 기초
### 정의
- REST - Representational State Transfer의 축약어로 웹 서비스를 제작하기 위한
아키텍처 스타일. 특정 언어나 플랫폼에 의존적이지 않으며 모바일 앱 기타 서비스와
같은 다양한 클라이언트들이 서로 통신할 수 있도록 하는데 이점이 있음.

- 구체적인 표준이 아니라 로이 필딩이라는 사람이 제시한 제약 조건에 가까움.
### 제약 조건
1. 상태 비저장
   - 서버는 클라이언트 상태에 관한 어떤 정보도 저장하지 않아야 한다.
2. 클라이언트-서버 간의 독립성
    - 클라이언트와 서버는 독립적으로 작동해야 한다. 서버는 클라이언트의 요청없이
        어떠한 정보도 전송해서는 안된다.
3. 캐시 가능
   - 여러 클라이언트가 동일한 리소스를 요청하는 경우가 많으므로 성능 향상을 위해
    리소스에 캐싱을 적용해야 한다.
4. 일관된 인터페이스
    - 서로 다른 클라이언트에 의한 요청이더라도 응답은 동일하게 보여야 한다.
    클라이언트의 예로는 브라우저, Java 애플리케이션, 모바일 애플리케이션 등
5. 계층형 시스템
    - 전체 서비스에 영향을 주지 않고 구성 요소를 추가하거나 수정할 수 있어야한다.
    이 제약 조건은 확장성과 관련이 있다.
6. 주문형 코드
    - 선택적 제약 조건으로, 대부분 서버는 정적 컨텐츠를 JSON 또는 XML
      (extended markup language) 형식으로 전송한다. 이 제약 조건은 필요한
    경우 서버가 정적 컨텐츠만이 아니라 실행 코드를 전송할 수 있어야 한다.

이상에서 일관된 인터페이스는 중요한 제약 조건이며 REST 아키텍처에 다음 요소가
포함될 필요가 있다.

- 리소스 식별
  - 리소스는고유 식별자(예- 웹 기반 REST 서비스의 URL)로 식별해야 함.
  - REST 리소스는 이해하기 쉬운 디렉토리 구조의 URL을 노출해야 함.
  - 이상을 이유로 리소스 명명 전략이 매우 중요.
- 표현을 통한 리소스 조작
  - 리소스를 요청(Request)할 때 서버는 리소스의 표현으로 응답(Response)해야함.
  - 일반적인 표현 형식으로는 JSON / XML
- 자체 설명적인 메시지
  - 메시지는 서버가 처리 방법을 알 수 있는 충분한 정보가 포함되어야 함.
- HATEOAS(HyperMedia As the Engine of Application State).
  - 응답에는 서비스의 다른 영역으로 연결되는 링크가 포함되어야 함.

다 작성하신 분들은 cardatabase2에 domain과 같은 위치에 web 패키지 생성
web 하위에 CarController 클래스 생성

## 스프링 부트로 RESTful 웹 서비스 만들기
1. cardatabase2에 domain과 같은 위치에 web 패키지 생성
2. web 하위에 CarController 클래스 생성
3. CarController 내부에
```java
package com.packt.cardatabase.web;

import org.springframework.web.bind.annotation.RestController;

@RestController
public class CarController {
}
```
4. @RestController 애너테이션은 해당 클래스가 RESTful 웹 서비스가 되도록 지정
5. CarController 클래스에 새로운 메서드를 추가합니다.
    메서드가 매핑되는 엔드포인트를 정의하는 @RequestMapping 애너테이션을 저장
    이하의 메서드는 '사용자가 /cars 엔드포인트로 GET 요청을 하면 getCars()
    메서드가 실행'된다.
    
    getCars() 메서드는 모든 자동차 객체를 반환한 다음에 Jackson 라이브러리에
    의해 자동으로 JSON 객체로 마샬링됩니다.
    * 마샬링 - 객체를 일련의 바이트로 변환하는 과정으로, 객체를 저장하거나 전송
        이 가능. 여기서는 Java 객체를 JSON 형식의 문자열로 변환하는 것이 해당 
   
    @GetMapping을 통해 /cars 엔드포인트의 GET 요청만 처리함.    
    다양한 HTTP 메서드(POST / GET / UPDATE / DELETE)에 대한
    애너테이션(@GetMapping / @PostMapping / @DeleteMapping 등)이 존재.

6. 데이터베이스에서 자동차를 반환할 수 있게 하려면 Controller에 CarRepository를
    주입해야 한다. 그런 다음 CrudRepository에서 제공하는 findAll() 메서드로
    모든 자동차를 검색할 수 있다.
    그러면 @RestController 애너테이션 덕분에 데이터가 응답에서 알아서
    JSON 형식의 문자열로 직렬화된다.

```java
package com.packt.cardatabase.web;

import com.packt.cardatabase.domain.Car;
import com.packt.cardatabase.domain.CarRepository;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class CarController {
    private final CarRepository repository;

    public CarController(CarRepository repository) {
        this.repository = repository;
    }

    @GetMapping("/cars")
    public Iterable<Car> getCars() {
        // 자동차를 검색하고나서 반환
        return repository.findAll();
    }

}
```

7. 이상의 코드를 작성하고 애플리케이션을 실행시킨 후에 엔드포인트인
    http://localhost:8080/cars 로 이동해보면, 무한루프 형태로 JSON 데이터가
    출력됨을 확인할 수 있다.

    이는 car 테이블과 owner 테이블 간의 일대다 관계 때문으로, 풀어서 설명하면
    먼저 자동차가 직렬화되면 연결된 소유자가 직렬화되고, 이어서 그 소유자가
    가진 자동차가 다시 직렬화되는 방식으로 첫 번째 car 데이터를 불러오면서
    무한 루프에 빠지는 것이다.

    이상을 해결하기 위한 방안 중 하나로는 Owner 클래스의 자동차 필드에
    @JsonIgnore 애너테이션을 이용하여 직렬화 프로세스 중에 자동차 필드를
    무시하도록 지정하는 것이다. 

    필요하지 않은 경우 양방향 매핑을 이용하지 않으므로써 문제를 해결할 수도 있는데
    @JsonIgnoreProperties 애너테이션을 함께 이용하여 하이버네이트가 생성된 필드를
    무시하는 방법도 있다.

    다하신 분은 Owner.java로 이동합니다.
    








