# 입실 체크 해주세요 !! 🚑

# 다른 요청 보호하기

20250516에는 로그인 단계를 작성했습니다. 이제 나머지 수신 요청에 대한 인증 처리
작업을 합니다. 인증 프로세스에는 요청이 컨트롤러에서 전달되기 전이나
클라이언트에게 응답이 전송되기 전에 일부 작업을 수행할 수 있는 _필터_ 를 이용합니다.

1. 필터 클래스를 이용하여 모든 다른 수신 요청을 인증처리할겁니다. 루트 패키지에
    AuthenticationFilter 클래스를 생성. 클래스는 스프링 시큐리티의
    OncePerRequestFilter 인터페이스를 _확장_ (extends) 하여 인증을 구현하는
    doFilterInternal 메서드를 제공. 요청에서 토큰을 확인하기 위해 필터
    클래스에서 JwtService 인스턴스를 주입해야 합니다. SecurityContextHolder를
    통하여 스프링 시큐리티가 인증된 사용자의 세부 정보를 저장할겁니다.

    코드를 통해서 이상의 메서드 및 클래스들을 확인하겠습니다.

```java
package com.packt.cardatabase;

import com.packt.cardatabase.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Component
public class AuthenticationFilter extends OncePerRequestFilter {
    private final JwtService jwtService;

    public AuthenticationFilter(JwtService jwtService) {
        this.jwtService = jwtService;
    }


    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {
        // 토큰 검증 및 사용자를 가져오기 # 1
        String jws = request.getHeader(HttpHeaders.AUTHORIZATION);
        if(jws != null) {
            // 토큰 검증 및 사용자를 가져오기 # 2
            String user = jwtService.getAuthUser(request);
            // 인증하기
            Authentication authentication =
                    new UsernamePasswordAuthenticationToken(user, null,
                            Collections.emptyList());

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }
}
```

2. 스프링 시큐리티 config 관련 필터 클래스를 추가해야 합니다. SecurityConfig 클래스에
아까 만든 AuthenticationFilter 클래스를 주입합니다.
```java
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    //추가된 부분
    private final AuthenticationFilter authenticationFilter;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter) {
        this.userDetailsService = userDetailsService;
        this.authenticationFilter = authenticationFilter;   // 추가된 부분
    }
}
```

3. SecurityConfig 클래스에서 filterChain 메서드를 수정하기 위한 과정을 거칩니다.
```java
package com.packt.cardatabase;

import com.packt.cardatabase.service.UserDetailsServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    //추가된 부분
    private final AuthenticationFilter authenticationFilter;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter) {
        this.userDetailsService = userDetailsService;
        //추가된 부분
        this.authenticationFilter = authenticationFilter;
    }

    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf((csrf) -> csrf.disable())
                .sessionManagement((sessionManagement) ->
                        sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests((authorizeRequests) ->
                        authorizeRequests.requestMatchers(HttpMethod.POST, "/login")
                                .permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class); // 추가된 부분

        return http.build();
    }
}
```
4. 전체 workflow 테스트 준비가 가능합니다. 애플리케이션 실행 후(오류나면 수정하러가겠습니다),
POST 메서드로 /login 엔드포인트를 호출하여 로그인이 가능합니다(금요일 마지막에 한 부분).
로그인에 성공하면 Authorization 헤더에 JWT를 받게 됩니다.
```json
{"username": "user", "password": "user"},

{"username": "admin", "password": "admin"}
```
으로 로그인했을 때입니다. postman으로 자동으로 지정되지 않는 경우는
Content-Type 헤더를 application/json으로 설정해야 합니다.















