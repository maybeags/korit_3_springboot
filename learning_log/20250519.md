# 입실 체크 해주세요 !! 🚑

# 다른 요청 보호하기

20250516에는 로그인 단계를 작성했습니다. 이제 나머지 수신 요청에 대한 인증 처리
작업을 합니다. 인증 프로세스에는 요청이 컨트롤러에서 전달되기 전이나
클라이언트에게 응답이 전송되기 전에 일부 작업을 수행할 수 있는 _필터_ 를 이용합니다.

1. 필터 클래스를 이용하여 모든 다른 수신 요청을 인증처리할겁니다. 루트 패키지에
    AuthenticationFilter 클래스를 생성. 클래스는 스프링 시큐리티의
    OncePerRequestFilter 인터페이스를 _확장_ (extends) 하여 인증을 구현하는
    doFilterInternal 메서드를 제공. 요청에서 토큰을 확인하기 위해 필터
    클래스에서 JwtService 인스턴스를 주입해야 합니다. SecurityContextHolder를
    통하여 스프링 시큐리티가 인증된 사용자의 세부 정보를 저장할겁니다.

    코드를 통해서 이상의 메서드 및 클래스들을 확인하겠습니다.

```java
package com.packt.cardatabase;

import com.packt.cardatabase.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Component
public class AuthenticationFilter extends OncePerRequestFilter {
    private final JwtService jwtService;

    public AuthenticationFilter(JwtService jwtService) {
        this.jwtService = jwtService;
    }


    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {
        // 토큰 검증 및 사용자를 가져오기 # 1
        String jws = request.getHeader(HttpHeaders.AUTHORIZATION);
        if(jws != null) {
            // 토큰 검증 및 사용자를 가져오기 # 2
            String user = jwtService.getAuthUser(request);
            // 인증하기
            Authentication authentication =
                    new UsernamePasswordAuthenticationToken(user, null,
                            Collections.emptyList());

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }
}
```

2. 스프링 시큐리티 config 관련 필터 클래스를 추가해야 합니다. SecurityConfig 클래스에
아까 만든 AuthenticationFilter 클래스를 주입합니다.
```java
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    //추가된 부분
    private final AuthenticationFilter authenticationFilter;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter) {
        this.userDetailsService = userDetailsService;
        this.authenticationFilter = authenticationFilter;   // 추가된 부분
    }
}
```

3. SecurityConfig 클래스에서 filterChain 메서드를 수정하기 위한 과정을 거칩니다.
```java
package com.packt.cardatabase;

import com.packt.cardatabase.service.UserDetailsServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    //추가된 부분
    private final AuthenticationFilter authenticationFilter;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter) {
        this.userDetailsService = userDetailsService;
        //추가된 부분
        this.authenticationFilter = authenticationFilter;
    }

    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf((csrf) -> csrf.disable())
                .sessionManagement((sessionManagement) ->
                        sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests((authorizeRequests) ->
                        authorizeRequests.requestMatchers(HttpMethod.POST, "/login")
                                .permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class); // 추가된 부분

        return http.build();
    }
}
```
4. 전체 workflow 테스트 준비가 가능합니다. 애플리케이션 실행 후(오류나면 수정하러가겠습니다),
POST 메서드로 /login 엔드포인트를 호출하여 로그인이 가능합니다(금요일 마지막에 한 부분).
로그인에 성공하면 Authorization 헤더에 JWT를 받게 됩니다.
```json
{"username": "user", "password": "user"},

{"username": "admin", "password": "admin"}
```
으로 로그인했을 때입니다. postman으로 자동으로 지정되지 않는 경우는
Content-Type 헤더를 application/json으로 설정해야 합니다.

## 예외 처리하기

현재 잘못된 암호를 이용하여 로그인을 시도하면 추가 설명은 없고 403 Forbidden이 발생
그래서 로그인에 실패했습니다 혹은 id/비밀번호가 틀렸습니다 와 같은 형태로
예외를 처리할 수 있도록 하는
AuthenticationEntryPoint 인터페이스를 사용할 예정입니다.

1. 루트 패키지에 AuthenticationEntryPoint를 _구현_ (implements)하는 AuthEntryPoint 클래스를
생성. 예외를 매개변수로 받는 commence를 받는 메서드를 구현할 예정입니다. 응답 상태를 401 Unauthorized으로
설정하고, 응답 본문에 예외 메시지를 작성할겁니다.
```java
package com.packt.cardatabase;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.PrintWriter;

@Component
public class AuthEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request
            , HttpServletResponse response
            , AuthenticationException authException) throws IOException, ServletException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        PrintWriter writer = response.getWriter();
        writer.println("Error(오류 발생) : " + authException.getMessage());
    }
}
```

2. 예외 처리를 위해 스프링 시큐리티를 구성해야합니다. AuthEntryPoint 클래스를 SecurityConfig
클래스에 주입해야합니다.

- 생성자 주입까지 처리하시면 되는데 이건 일부러 코드블럭으로 남기지 않겠습니다.(위에서 했습니다)

3. filterChain()을 또 수정해야합니다. -> 코드 안적어줄겁니다 가서 확인하세요.


## CORS 필터 추가하기

SecurityConfig 클래스에 CORS(Cross-Origin Resources Sharing) 필터를 추가할 예정입니다.
CORS란 클라이언트와 서버가 교차(Cross) 출처 재요청을 허용할지 거부할지를 결정하게 하는 특정 헤더를 추가합니다.
CORS 필터는 다른 출처에서 요청을 보내는 frontend에서 필요합니다.(보통 이거 설정 안하고 프론트엔드작업하다가
back-front 통합 시에 오류 나는 분들이 많습니다)
CORS 필터는 요청에 간섭하여, 교차 출처로 식별되면 요청에 적절한 헤더를 추가합니다. 이를 위해서
CorsConfigurationSource 인터페이스를 이용합니다.

1. SecurityConfig 클래스에 import문과 메서드를 추가하여 CORS 필터를 활성화합니다.

```java
    // 클래스 내에 전역 CORS 필터 추가
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList("*"));
        config.setAllowedMethods(Arrays.asList("*"));
        config.setAllowedHeaders(Arrays.asList("*"));
        config.setAllowCredentials(false);
        config.applyPermitDefaultValues();
        
        source.registerCorsConfiguration("/**", config);
        return source;
        
    }
```
출처를 명시적으로 정의하려면?(예를 들어 localhost:3000을 허용하려면) -> 이하와 같이 씁니다. 저희는 전체 허용으로 작성했습니다.↑
```java
config.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
```

2. 또 filterChain() 추가해야합니다.
```java
    @Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.csrf((csrf) -> csrf.disable())
            .cors(Customizer.withDefaults())
            .sessionManagement((sessionManagement) ->
                    sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests((authorizeRequests) ->
                    authorizeRequests.requestMatchers(HttpMethod.POST, "/login")
                            .permitAll().anyRequest().authenticated())
            .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling((exceptionHandling) ->
                    exceptionHandling.authenticationEntryPoint(exceptionHandler));

    return http.build();
}
```
이상이 filterChain의 거의 최종 버전에 해당하는데 CORS의 경우에는 프론트엔드와의 통신 상에서 사용하기 때문에 현재 검증은 어렵습니다.
그 와중에 cors() 메서드 내에 있는 arguement가 Customizer.withDefaults로 작성되어있습니다.
이게 문제되는건 아닌데 짧게 쓰기 위해서 수동으로 import문을 쓸 때가 있습니다.
그래서 저희는 md 파일에는 자동 생성 형태를 남겨두고, SecurityConfig.java 파일은 수동 import를 작성한 버전을 남겨두겠습니다.
차이점도 별로 없고 해서 어떤 방식으로 작성하든 관계 없습니다.

이상까지 완료하면 백엔드 보호를 위한 다양한 과정을 거쳤습니다. protection에 초점을 맞춘 만큼 SecurityConfig 클래스를
중점적으로 작성했음을 확인할 수 있습니다.

다음으로는

## 역할 기반 보안













